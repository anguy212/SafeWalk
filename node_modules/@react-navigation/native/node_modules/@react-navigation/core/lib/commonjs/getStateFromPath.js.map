{"version":3,"sources":["getStateFromPath.tsx"],"names":["getStateFromPath","path","options","initialRoutes","configs","concat","Object","keys","map","key","createNormalizedConfigs","sort","config1","config2","pattern","split","length","remaining","replace","endsWith","match","find","config","routeNames","every","name","c","screen","createNestedStateObject","parseQueryParams","parse","undefined","result","current","params","paramPatterns","filter","p","startsWith","reduce","acc","i","value","segments","decodeURIComponent","shift","join","state","routes","index","route","findFocusedRoute","findParseConfigForRoute","routeConfig","initials","push","createConfigItem","screens","initialRouteName","connectedRoutes","forEach","nestedConfig","pop","RegExp","it","routeName","flatConfig","findInitialRoute","includes","createStateObject","initialRoute","isEmpty","nestedState","parseConfig","query","queryString"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  screen: string;\n  match: RegExp | null;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map((key) =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  // sort configs so the most exhaustive is always first to be chosen\n  configs.sort(\n    (config1, config2) =>\n      config2.pattern.split('/').length - config1.pattern.split('/').length\n  );\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.pattern === '' &&\n        config.routeNames.every(\n          // make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.pattern\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        match.routeNames,\n        initialRoutes,\n        parseQueryParams(path, match.parse)\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      if (!config.match) {\n        continue;\n      }\n\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '').replace(/\\?$/, '');\n            const value = match[(i + 1) * 2].replace(/\\//, ''); // The param segments appear every second item starting from 2 in the regex match result\n\n            if (value) {\n              acc[key] =\n                config.parse && config.parse[key]\n                  ? config.parse[key](value)\n                  : value;\n            }\n\n            return acc;\n          }, {});\n        }\n\n        remaining = remaining.replace(match[1], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    const state = createNestedStateObject(routeNames, initialRoutes, params);\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const route = findFocusedRoute(current);\n  const params = parseQueryParams(\n    path,\n    findParseConfigForRoute(route.name, configs)\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    configs.push(createConfigItem(key, routeNames, value));\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof value.path === 'string') {\n      configs.push(createConfigItem(key, routeNames, value.path, value.parse));\n    }\n\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = pattern\n    ? new RegExp(\n        `^(${pattern\n          .split('/')\n          .map((it) => {\n            if (it.startsWith(':')) {\n              return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n            }\n\n            return `${escape(it)}\\\\/`;\n          })\n          .join('')})`\n      )\n    : null;\n\n  return {\n    screen,\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createStateObject(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n\nfunction createNestedStateObject(\n  routeNames: string[],\n  initialRoutes: InitialRouteConfig[],\n  params: object | undefined\n) {\n  let state: InitialState;\n  let routeName = routeNames.shift() as string;\n  let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n  state = createStateObject(\n    initialRoute,\n    routeName,\n    routeNames.length === 0,\n    params\n  );\n\n  if (routeNames.length > 0) {\n    let nestedState = state;\n\n    while ((routeName = routeNames.shift() as string)) {\n      initialRoute = findInitialRoute(routeName, initialRoutes);\n      nestedState.routes[nestedState.index || 0].state = createStateObject(\n        initialRoute,\n        routeName,\n        routeNames.length === 0,\n        params\n      );\n      if (routeNames.length > 0) {\n        nestedState = nestedState.routes[nestedState.index || 0]\n          .state as InitialState;\n      }\n    }\n  }\n\n  return state;\n}\n\nfunction findFocusedRoute(state: InitialState) {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index || 0].state) {\n    // The query params apply to the deepest route\n    current = current.routes[current.index || 0].state;\n  }\n\n  const route = (current as PartialState<NavigationState>).routes[\n    current?.index || 0\n  ];\n\n  return route;\n}\n\nfunction parseQueryParams(\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}\n"]}